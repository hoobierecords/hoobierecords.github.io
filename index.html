<!DOCTYPE html>
<html lang="en">
<head>
<!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-KYREC4C6D1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-KYREC4C6D1');
</script>

<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- plasma-->
<link href="css/plasma.css" type="text/css" rel="stylesheet" />
<title>Hoobie Records</title>

<style>
@font-face {
  font-family: 'Bebas Neue';
  src: url('fonts/BebasNeue-Regular.ttf') format('truetype');
  font-weight: normal;
  font-style: normal;
  font-display: swap;
}
:root {
  --bg: rgb(255, 234, 0);
  --panel: #000000;
  --accent: #ff0000;
  --text: #e8e9f0;
  --muted: #fffa69;
}

* {
  box-sizing: border-box;
  margin: 0;
  /* font-family: system-ui, -apple-system, BlinkMacSystemFont, sans-serif; */
  font-family: 'Bebas Neue', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
}

body {
   /* background: radial-gradient(circle at top, #2a1414, var(--bg)); */
  background-color:yellow;
  background-image: linear-gradient(rgb(238, 255, 0), rgb(255, 0, 0));
  color: var(--text);
  line-height: 1.6;
  padding-top: 64px;
}

/* ---------- NAV ---------- */
nav.top-nav {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  height: 64px;
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0 1.25rem;
  gap: 1rem;
  background: rgb(0, 0, 0);
  backdrop-filter: blur(6px);
  z-index: 1000;
  border-bottom: 1px solid rgba(255,255,255,0.04);
}

nav.top-nav .brand {
  font-weight: 700;
  letter-spacing: 0.5px;
}

nav.top-nav .links {
  display: flex;
  gap: 1rem;
}

/* navbar logo on the right */
.nav-logo {
  order: 2;
  height: 56px;
  max-height: 56px;
  margin-left: auto;
  pointer-events: none;
  margin-top: 25px;
}

@media (max-width: 640px) {
  .nav-logo { height: 40px; max-height: 40px; margin-top: 10px; }
}

/* place links on left, brand on right */
nav.top-nav .links { order: 1; }
nav.top-nav .brand { order: 2; }

/* accessible visually-hidden helper */
.sr-only {
  position: absolute !important;
  width: 1px !important;
  height: 1px !important;
  padding: 0 !important;
  margin: -1px !important;
  overflow: hidden !important;
  clip: rect(0, 0, 0, 0) !important;
  white-space: nowrap !important;
  border: 0 !important;
}

/* Mobile: collapse links into dropdown */
nav.top-nav .nav-toggle {
  display: none;
  background: transparent;
  border: none;
  color: var(--text);
  font-size: 1.25rem;
  cursor: pointer;
}

@media (max-width: 640px) {
  nav.top-nav {
    padding: 0 0.75rem;
  }

  /* show toggle */
  nav.top-nav .nav-toggle { display: block; order: 1; }

  /* stack links as dropdown */
  nav.top-nav .links {
    position: absolute;
    left: 0;
    right: 0;
    top: 64px;
    background: rgba(10,12,20,0.95);
    flex-direction: column;
    display: flex;
    max-height: 0;
    overflow: hidden;
    padding: 0 0.5rem;
    gap: 0.5rem;
    transition: max-height 280ms ease, opacity 200ms ease, padding 200ms ease;
    opacity: 0;
    pointer-events: none;
  }

  nav.top-nav .links.open {
    max-height: 420px;
    opacity: 1;
    pointer-events: auto;
    padding: 0.5rem 1rem 1rem 1rem;
  }

  nav.top-nav .links a {
    padding: 0.5rem 0.75rem;
    border-radius: 8px;
    display: block;
  }

  /* keep brand on right */
  nav.top-nav .brand { order: 2; }
}

nav.top-nav a {
  color: var(--bg);
  text-decoration: none;
  padding: 0.35rem 0.5rem;
  font-size: 0.95rem;
}

nav.top-nav a:hover {
  color: var(--accent);
}

/* ---------- HERO ---------- */
header {
  padding: 5rem 1.5rem;
  text-align: center;
}

/* Header background image */
/* Header now uses a video background that covers the header area */
header.hoobie-records-header-bgk {
  position: relative;
  overflow: hidden;
  width: 100%;
  aspect-ratio: 1260 / 720;
  margin: 0;
  padding: 0;
  color: var(--text);
}

header.hoobie-records-header-bgk video.header-bg {
  position: absolute;
  inset: 0;
  width: 100%;
  height: 100%;
  object-fit: cover;
  z-index: 0;
  filter: drop-shadow(0px 0px 10px Red);
  opacity: 0;
  transition: opacity 300ms ease;
}

header.hoobie-records-header-bgk .header-content {
  position: relative;
  z-index: 1;
}

.about-content {
  text-align: center;
  padding: 3rem 1.5rem;
  max-width: 1100px;
  margin: auto;
  position: relative;
  z-index: 2;
}

.about-content h1 {
  font-family: 'Bebas Neue', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  font-size: clamp(2.5rem, 5vw, 3.5rem);
  letter-spacing: 1px;
}

.about-content h1 span {
  color: var(--accent);
  text-shadow: 0px 0px 3px yellow;
  filter: drop-shadow(0px 0px 15px rgb(0, 0, 0));
}

.about-content p {
  margin-top: 1rem;
  max-width: 650px;
  margin-inline: auto;
  color: var(--muted);
  text-shadow: 0px 0px 3px rgb(0, 0, 0);
  filter: drop-shadow(0px 0px 2px rgb(0, 0, 0));
}

/* small controls overlay */
.header-controls {
  position: relative;
  left: auto;
  bottom: auto;
  z-index: 2;
  display: flex;
  gap: 0.5rem;
  align-items: center;
  justify-content: flex-start;
  padding: 0rem 1.5rem 1rem 1.5rem;
  text-shadow: 0px 0px 3px rgb(0, 0, 0);
  filter: drop-shadow(0px 0px 2px rgb(0, 0, 0));
}

.header-controls button {
  background: var(--accent);
  color: var(--muted);
  border: 1px solid black;
  text-shadow: 0px 0px 3px rgb(0, 0, 0);
  /* filter: drop-shadow(0px 0px 2px rgb(0, 0, 0)); */
  padding: .35rem 0.6rem;
  border-radius: 8px;
  cursor: pointer;
  transition: transform 0.25s ease, box-shadow 0.25s ease;
}

.header-controls button:hover {
  background: var(--muted);
  color: var(--accent);
  transform: scale(1.05);
}

.header-controls input[type="range"]{
  -webkit-appearance: none;
  width: 160px;
  height: 6px;
  background: linear-gradient(90deg, var(--accent), #ffb3b3);
  border: 1px solid black;
  filter: drop-shadow(0px 0px 2px rgb(0, 0, 0));
  border-radius: 6px;
  outline: none;
}

.header-controls input[type="range"]::-webkit-slider-thumb{
  -webkit-appearance: none;
  width: 14px;
  height: 14px;
  background: #ff2222;
  border-radius: 50%;
  box-shadow: 0 0 6px rgba(255,34,34,0.6);
  cursor: pointer;
  margin-top: -4px;
}

.header-controls input[type="range"]::-moz-range-thumb{
  width: 14px;
  height: 14px;
  background: #ff2222;
  border-radius: 50%;
  cursor: pointer;
}

header h1 {
  font-family: 'Bebas Neue', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  font-size: clamp(2.5rem, 5vw, 3.5rem);
  letter-spacing: 1px;
  /* color: var(--accent); */
  /* text-shadow: 0px 0px 3px yellow; */
}

header h1 span {
  color: var(--accent);
  text-shadow: 0px 0px 3px yellow;
  filter: drop-shadow(0px 0px 15px rgb(0, 0, 0));
}

header p {
  margin-top: 1rem;
  max-width: 650px;
  margin-inline: auto;
  color: var(--muted);
  text-shadow: 0px 0px 3px Red;
  filter: drop-shadow(0px 0px 2px rgb(255, 0, 0));
}

/* ---------- SECTIONS ---------- */
section {
  /* padding: 4rem 1.5rem; */
  max-width: 1100px;
  margin: auto;
  z-index: 2;
}

h2 {
  font-family: 'Bebas Neue', system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
  font-size: 2rem;
  margin-bottom: 1rem;
  color: var(--bg);
    text-shadow: 0px 0px 1px red;
}

/* ---------- RELEASE GRID ---------- */
.grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 1.5rem;
}

.release {
  background: var(--panel);
  border-radius: 14px;
  padding: 1.5rem;
  cursor: pointer;
  transition: transform 0.25s ease, box-shadow 0.25s ease;
}

.release:hover {
  transform: translateY(-5px);
  box-shadow: 0 0 5px 5px rgb(255, 255, 255);
}

.release img {
  width: 100%;
  border-radius: 10px;
  margin-bottom: 1rem;
}

.release p {
  font-size: 0.8rem;
  color: var(--muted);
}

.release a {
  text-decoration: none;
  color: #ff2222;
}

.release a:visited {
  text-decoration: none;
  color: rgb(245, 224, 0);
}

.release a:hover {
  text-decoration: none;
  color: rgb(245, 224, 0);
}

#enter h2{
  text-align: center;
  color: #fffa69;
  text-shadow: 0px 0px 3px rgb(0, 0, 0);
}

 #enter h3{
  color: #fffa69;
  text-shadow: 0px 0px 3px rgb(0, 0, 0);
}

  #enter h4{
  font-size: 0.9rem;
  color: #fffa69;
  text-shadow: 0px 0px 3px rgb(0, 0, 0);
}

    #enter h5{
  font-size: 0.8rem;
  color: #ff2222;
}

#enter {
  position: relative;
  z-index: 2;
}

/* Ensure the canvas sits behind content and doesn't block interactions */
#canvas {
  position: fixed;
  inset: 0;
  width: 100%;
  height: 100%;
  display: block;
  z-index: -1;
  pointer-events: none;
}

/* ---------- ENTER BUTTON ---------- */
.enter-button {
  background: var(--accent);
  color: var(--bg);
  border: 1px solid black;
  box-shadow: 0px 0px 7px rgba(0, 0, 0, 0.6);
  padding: 1rem 2rem;
  font-size: 1.5rem;
  font-weight: bold;
  text-shadow: 0px 0px 2px rgb(0, 0, 0);
  border-radius: 8px;
  cursor: pointer;
  transition: transform 0.25s ease, box-shadow 0.25s ease;
  display: block;
  margin: 4rem auto;
  font-family: 'Bebas Neue', system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  letter-spacing: 1px;
}

.enter-button:hover {
  background: var(--bg);
  color: var(--accent);
  transform: scale(1.05);
  box-shadow: 0 0 15px rgba(255, 0, 0, 0.7);
}

.enter-button:active {
  transform: scale(0.98);
}

/* ---------- FOOTER ---------- */
footer {
  text-align: center;
  padding: 2rem;
  color: var(--muted);
  font-size: 0.9rem;
  text-shadow: 0px 0px 3px rgb(0, 0, 0);
}
</style>
</head>

<body>
<div id="container-plasma">

  <nav class="top-nav" role="navigation" aria-label="Main navigation">
    <button class="nav-toggle" aria-expanded="false" aria-controls="navLinks" aria-label="Toggle navigation">
      <span class="sr-only">Toggle navigation</span>
      ☰
    </button>
    <div class="links" id="navLinks">
      <a href="index.html">Home</a>
      <a href="releases.html">Releases</a>
      <a href="#about">About</a>
      <a href="#contact">Contact</a>
    </div>
    <img src="images/hoobie-records-navbar-brand.png" alt="Hoobie Records" class="nav-logo">
  </nav>

  <!-- HERO / INFO -->
  <header class="hoobie-records-header-bgk">
    <video id="headerVideo" class="header-bg" autoplay muted playsinline></video>
  </header>

  <!-- VIDEO CONTROLS -->
  <div class="header-controls">
    <button id="videoToggle" aria-pressed="false">Pause</button>
    <input id="volumeSlider" type="range" min="0" max="1" step="0.01" value="0.8" aria-label="Volume">
  </div>
<canvas id="canvas"></canvas>

  <!-- ABOUT SECTION -->
  <section class="about-content">
    <h1><span>Hoobie Records</span></h1>
    <p>
    Welcome to the abyss of sound—Hoobie Records! Home to the most depraved, deranged artists the world has ever known, where chaos reigns and sanity is a distant memory. Witness the screams, the madness, the unholy symphonies of the notorious. Enter if you dare, but beware: once you listen, there's no turning back from the darkness... this is music from the edge of madness!
    </p>
    <p>
    Created in 2007 by Scum Puppy, Hoobie Records showcases live human absurdities and the world's worst musical depravity. Join Us. Shall you?
    </p>
  </section>
  <!-- ENTER RELEASES -->
  <section id="enter">
    <button id="enterButton" class="enter-button">Enter</button>
  </section>

  <footer>
    © <script>document.write(new Date().getFullYear());</script> Hoobie Records
  </footer>
  
</div>

  <script>
  // Mobile nav toggle
  (function(){
    const toggle = document.querySelector('.nav-toggle');
    const links = document.getElementById('navLinks');
    if (!toggle || !links) return;

    toggle.addEventListener('click', function(e){
      const isOpen = links.classList.toggle('open');
      this.setAttribute('aria-expanded', isOpen);
    });

    // Close dropdown when a link is clicked
    links.querySelectorAll('a').forEach(a => {
      a.addEventListener('click', () => {
        links.classList.remove('open');
        toggle.setAttribute('aria-expanded', 'false');
      });
    });

    // Close when clicking outside the nav
    document.addEventListener('click', (e) => {
      if (!links.classList.contains('open')) return;
      if (e.target.closest && e.target.closest('nav.top-nav')) return;
      links.classList.remove('open');
      toggle.setAttribute('aria-expanded', 'false');
    });

    // Close on Escape
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && links.classList.contains('open')) {
        links.classList.remove('open');
        toggle.setAttribute('aria-expanded', 'false');
        toggle.focus();
      }
    });
  })();
  </script>

  <script>
  // Enter button click handler
  (function(){
    const enterButton = document.getElementById('enterButton');
    if (enterButton) {
      enterButton.addEventListener('click', () => {
        window.location.href = 'releases.html';
      });
    }
  })();
  </script>

  <script>
  (function(){
    const video = document.getElementById('headerVideo');
    const toggle = document.getElementById('videoToggle');
    const slider = document.getElementById('volumeSlider');

    // optional label for debugging / display
    const label = document.createElement('span');
    label.id = 'videoLabel';
    label.style.marginLeft = '0.5rem';
    label.style.color = 'var(--muted)';
    label.style.fontSize = '0.85rem';
    document.querySelector('.header-controls').appendChild(label);

    // Use a hardcoded playlist from the `mp4/hom/` folder (filenames provided by user)
    const knownFiles = [
      'hom/jimson-sirkus-welcome-to-the-bigtop-welcome-to-the-pain.mp4',
      'hom/scum-puppy-alabama-b-boy-mosh-pit.mp4',
      'hom/scum-puppy-dogman-of-benton-harbor-michigan.mp4',
      'hom/the-semi-flying-headless-screaming-thrashing-chickens-nightmare.mp4'
    ];

    // playlist uses URL-encoded paths so spaces and special chars load correctly
    let playlist = knownFiles.map(f => encodeURI('mp4/' + f));
    let stopped = false;
    let currentIndex = -1;

    function pickRandomIndex(){
      if (!playlist || playlist.length === 0) return -1;
      if (playlist.length === 1) return 0;
      let idx;
      let attempts = 0;
      do {
        idx = Math.floor(Math.random() * playlist.length);
        attempts++;
      } while (idx === currentIndex && attempts < 10);
      return idx;
    }

    async function buildPlaylist(){
      // we already have a known playlist; leave as-is.
      return;
    }

    function setLabel(text){
      if (label) label.textContent = text || '';
    }

    function playNext(){
      if (stopped) return;
      const idx = pickRandomIndex();
      if (idx < 0) {
        setLabel('No videos found');
        return;
      }
      const src = playlist[idx];
      currentIndex = idx;
      // display filename without folder and decoded
      try { setLabel(decodeURIComponent(src).replace(/^mp4\//, '')); } catch(e){ setLabel(src); }
      video.src = src;
      video.load();
      video.play().then(() => {
        video.style.opacity = '1';
        toggle.textContent = 'Pause';
        toggle.setAttribute('aria-pressed','false');
        // Attempt to unmute after a successful autoplay (may be blocked by browser).
        tryUnmuteAfterAutoplay();
      }).catch(() => {
        // On error (file not found / blocked), remove that candidate and try another
        // update currentIndex if needed
        playlist = playlist.filter((p, i) => {
          if (i === currentIndex) currentIndex = -1;
          return p !== src;
        });
        setTimeout(playNext, 200);
      });
    }

    // Try to unmute programmatically after autoplay; browsers may still block audible autoplay.
    function tryUnmuteAfterAutoplay(){
      const v = slider ? parseFloat(slider.value) : 1;
      if (v > 0) {
        try {
          video.muted = false;
          video.volume = v;
          // replay to ensure audio starts (may be rejected if browser blocks unmute)
          video.play().catch(()=>{});
        } catch(e) {}
      }
    }

    // Ensure a user gesture will unmute (guaranteed by policy). Listen once.
    function unmuteOnGesture(){
      const v = slider ? parseFloat(slider.value) : 1;
      try {
        video.muted = false;
        video.volume = v;
        if (video.paused && !stopped) video.play().catch(()=>{});
      } catch(e) {}
    }
    document.addEventListener('click', unmuteOnGesture, { once: true, capture: true });
    document.addEventListener('keydown', unmuteOnGesture, { once: true, capture: true });

    // initialize volume slider behavior
    if (slider) {
      // set initial volume (will unmute when user moves slider)
      try { video.volume = parseFloat(slider.value); } catch(e){}
      slider.addEventListener('input', (e) => {
        const v = parseFloat(e.target.value);
        video.volume = v;
        if (v > 0) {
          video.muted = false;
        }
        // ensure video plays if user adjusts volume while paused
        if (video.paused && !stopped) {
          video.play().catch(()=>{});
        }
      });
    }

    video.addEventListener('playing', () => {
      video.style.opacity = '1';
    });

    video.addEventListener('ended', () => {
      setTimeout(playNext, 150);
    });

    video.addEventListener('error', () => {
      if (video.src) {
        const url = video.src;
        playlist = playlist.filter(p => p !== url && !url.endsWith(p));
      }
      setTimeout(playNext, 200);
    });

    toggle.addEventListener('click', () => {
      if (!video) return;
      if (video.paused) {
        stopped = false;
        // user-initiated play -> unmute if slider > 0
        if (slider && parseFloat(slider.value) > 0) video.muted = false;
        video.play().catch(()=>{});
        toggle.textContent = 'Pause';
        toggle.setAttribute('aria-pressed','false');
      } else {
        video.pause();
        stopped = true;
        toggle.textContent = 'Play';
        toggle.setAttribute('aria-pressed','true');
      }
    });

    document.addEventListener('DOMContentLoaded', async () => {
      await buildPlaylist();
      if (!playlist || playlist.length === 0) {
        setLabel('No videos found in mo4/');
        toggle.disabled = true;
        return;
      }
      stopped = false;
      playNext();
    });
  })();
  </script>


<script>
    const canvas = document.getElementById("canvas");
    const c = canvas.getContext("2d");

    // size of canvas
    const imgSize = 512;

    canvas.width = imgSize;
    canvas.height = imgSize;

    // init image data with black pixels
    const image = c.createImageData(imgSize, imgSize);
    for (let i = 0; i < image.data.length; i += 4) {
      image.data[i] = 0; // R
      image.data[i + 1] = 0; // G
      image.data[i + 2] = 0; // B
      image.data[i + 3] = 255; // A
    }

    // size of our height maps
    const mapSize = 1024;

    // returns the distance of point x,y from the origin 0,0
    const distance = (x, y) => Math.sqrt(x * x + y * y);
  


    // init height map 1
    const heightMap1 = [];
    for (let u = 0; u < mapSize; u++) {
      for (let v = 0; v < mapSize; v++) {
        // index of coordinate in height map array
        const i = u * mapSize + v;

        // u,v are coordinates with origin at upper left corner
        // cx and cy are coordinates with origin at the
        // center of the map
        const cx = u - mapSize / 2;
        const cy = v - mapSize / 2;

        // distance from middle of map
        const d = distance(cx, cy);

        // stretching so we get the desired ripple density on our map
        const stretch = (3 * Math.PI) / (mapSize / 2);

        // wavy height value between -1 and 1
        const ripple = Math.sin(d * stretch);

        // wavy height value normalized to 0..1
        const normalized = (ripple + 1) / 2;

        // height map value 0..128, integer
        heightMap1[i] = Math.floor(normalized * 128);
      }
    }

    const heightMap2 = [];
    for (let u = 0; u < mapSize; u++) {
      for (let v = 0; v < mapSize; v++) {
        const i = u * mapSize + v;
        const cx = u - mapSize / 2;
        const cy = v - mapSize / 2;

        // skewed distance as input to chaos field calculation,
        // scaled for smoothness over map distance
        const d1 = distance(0.8 * cx, 1.3 * cy) * 0.022;
        const d2 = distance(1.35 * cx, 0.45 * cy) * 0.022;

        const s = Math.sin(d1);
        const c = Math.cos(d2);
        // height value between -2 and +2
        const h = s + c;

        // height value between 0..1
        const normalized = (h + 2) / 4;
        // height value between 0..127, integer
        heightMap2[i] = Math.floor(normalized * 127);
      }
    }

    // offsets for moving height maps
    let dx1 = 0;
    let dy1 = 0;

    let dx2 = 0;
    let dy2 = 0;

    // adjust height maps offsets
    const moveHeightMaps = t => {
      dx1 = Math.floor(
        (((Math.cos(t * 0.0002 + 0.4 + Math.PI) + 1) / 2) * mapSize) / 2
      );
      dy1 = Math.floor((((Math.cos(t * 0.0003 - 0.1) + 1) / 2) * mapSize) / 2);
      dx2 = Math.floor((((Math.cos(t * -0.0002 + 1.2) + 1) / 2) * mapSize) / 2);
      dy2 = Math.floor(
        (((Math.cos(t * -0.0003 - 0.8 + Math.PI) + 1) / 2) * mapSize) / 2
      );
    };

    const updateImageData = () => {
      for (let u = 0; u < imgSize; u++) {
        for (let v = 0; v < imgSize; v++) {
          // indexes into height maps for pixel
          const i = (u + dy1) * mapSize + (v + dx1);
          const k = (u + dy2) * mapSize + (v + dx2);

          // index for pixel in image data
          // remember it's 4 bytes per pixel
          const j = u * imgSize * 4 + v * 4;

          // height value of 0..255
          let h = heightMap1[i] + heightMap2[k];

          // map grayscale height to a red -> yellow gradient
          // red stays at max, green varies with `h`, blue is zero
          const g = Math.max(0, Math.min(255, Math.floor(h)));
          const r = 255;
          const b = 0;

          // set pixel data
          image.data[j] = r;
          image.data[j + 1] = g;
          image.data[j + 2] = b;
        }
      }
    };

    const tick = time => {
      moveHeightMaps(time);
      updateImageData();

      c.putImageData(image, 0, 0);

      requestAnimationFrame(tick);
    };

    requestAnimationFrame(tick);



  </script>

  </body>
  </html>
